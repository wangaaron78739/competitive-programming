/**
 * Description: Eulerian path starting at \texttt{src} if it exists, 
 	* visits all edges exactly once. Works for both directed and 
 	* undirected. Returns vector of {vertex,label of edge to vertex}.
 	* The second element of the first pair is always $-1$.
 * Time: O(N+M)
 * Source: USACO Training, MIT ICPC Notebook
 * Verification:
	* directed -> https://open.kattis.com/problems/eulerianpath
	* undirected -> USACO Training 3.3, Riding the Fences
 */
 
template<int SZ, bool directed> struct Euler {
	int N; vpi adj[SZ]; vpi::iterator its[SZ];
	vector<bool> used;
	void ae(int a, int b) {
		int M = sz(used); used.pb(0); 
		adj[a].eb(b,M); if (!directed) adj[b].eb(a,M); }
	vpi solve(int _N, int src = 0) {
		N = _N; F0R(i,N) its[i] = begin(adj[i]);
		vector<pair<pi,int>> ret, s = {{{src,-1},-1}}; 
		// {{vert, prev vert}, edge label}
		while (sz(s)) {
			int x = s.bk.f.f; auto& it = its[x], en = end(adj[x]);
			while (it != en && used[it->s]) it ++;
			if (it == en) { // no more edges out of vertex
				if (sz(ret) && ret.bk.f.s != x) return {}; 
				ret.pb(s.bk), s.pop_back(); 
			} else { s.pb({{it->f,x},it->s}); used[it->s] = 1; }
		}
		if (sz(ret) != sz(used)+1) return {};
		vpi ans; trav(t,ret) ans.pb({t.f.f,t.s});
		reverse(all(ans)); return ans;
	}
};
 
/**
 * Description: Disjoint Set Union with path compression
 	* and union by size. Add edges and test connectivity. 
 	* Use for Kruskal's or Boruvka's minimum spanning tree.
 * Time: O(\alpha(N))
 * Source: CSAcademy, KACTL
 * Verification: USACO superbull
 */
 
struct DSU {
	vi e; void init(int n) { e = vi(n,-1); }
	int get(int x) { return e[x] < 0 ? x : e[x] = get(e[x]); } 
	bool sameSet(int a, int b) { return get(a) == get(b); }
	int size(int x) { return -e[get(x)]; }
	bool unite(int x, int y) { // union by size
		x = get(x), y = get(y); if (x == y) return 0;
		if (e[x] > e[y]) swap(x,y);
		e[x] += e[y]; e[y] = x; return 1;
	}
};
 
/**template<class T> T kruskal(int n, vector<pair<T,pi>> ed) {
	sort(all(ed));
	T ans = 0; DSU D; D.init(n+1); // edges that unite are in MST
	trav(a,ed) if (D.unite(a.s.f,a.s.s)) ans += a.f; 
	return ans;
}*/
 
 
Euler<1<<20,0> E;